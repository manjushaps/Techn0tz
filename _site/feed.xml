<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/Techn0tz/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/Techn0tz/" rel="alternate" type="text/html" /><updated>2025-05-03T09:30:27+05:30</updated><id>http://localhost:4000/Techn0tz/feed.xml</id><title type="html">Techn0tz</title><entry><title type="html">Git Series: Part 3 - Branching and Merging</title><link href="http://localhost:4000/Techn0tz/git/2025/05/02/Git-Series-Part-3.html" rel="alternate" type="text/html" title="Git Series: Part 3 - Branching and Merging" /><published>2025-05-02T00:00:00+05:30</published><updated>2025-05-02T00:00:00+05:30</updated><id>http://localhost:4000/Techn0tz/git/2025/05/02/Git-Series-Part-3</id><content type="html" xml:base="http://localhost:4000/Techn0tz/git/2025/05/02/Git-Series-Part-3.html"><![CDATA[<h1 id="how-git-stores-data">ğŸ“How Git stores Data?</h1>
<p>Before diving into branching, itâ€™s important to understand how Git stores your project.
Unlike some older version control systems, Git doesnâ€™t store data as a series of changesets or differences. Instead, it stores your project as a series of snapshots.</p>

<p>Each time you commit, Git captures the full state of your project â€” like taking a photo of all your files at that moment.</p>

<p>But a commit does more than just save a message. It also records the complete snapshot, links to its parent commit, and silently builds the structure that makes branching possible.</p>

<p>This creates a chain â€” each commit pointing to the one before it â€” forming a structure called a <strong>Directed Acyclic Graph (DAG)</strong>.</p>

<p>For example.. <strong><code class="language-plaintext highlighter-rouge">[C0]&lt;--[C1]&lt;--[C2]....</code></strong> (C - commits, C0 is the initial commit, C1 is the next and so on)</p>

<hr />
<h1 id="commit-internals">ğŸ“ŒCommit internals</h1>
<p>With that foundation, itâ€™s time to explore what actually makes up a Git commit.</p>

<p>Behind every commit is a compact data structure that stores your projectâ€™s snapshot, tracks changes over time, and links everything together. Understanding this internal structure helps you see how branching â€” and Gitâ€™s powerful history tracking â€” works under the hood.</p>

<p>When you run <strong>git commit</strong>, Git creates a commit object that includes:</p>
<ul>
  <li><em>A pointer to a tree</em> - The tree object represents the snapshot of your project directory.It also maps file names to blobs (file contents) and subfolders to other trees.</li>
  <li><em>Parent commit</em> - The parent commit is just a pointer (a SHA-1 hash) to the previous commit(s).Each commit (except the first) points back to at least one parent and a merge commit has multiple parents.</li>
  <li><em>Metadata</em> - Author name, email, timestamp and committer info (can be different)</li>
  <li><em>Commit message</em> - The message  for the commit given in <strong>git commit -M message</strong></li>
</ul>

<p><em>For example if you commit three files, the Git repository contains five objects:</em></p>
<ul>
  <li><strong>Three Blobs:</strong> These blobs represent the contents of each file.</li>
  <li><strong>One tree:</strong> This tree object holds the folder structure and file names.</li>
  <li><strong>One commit:</strong> The commit object points to the tree and stores metadata like the author, commit message, and timestamp.</li>
</ul>

<p><img src="/Techn0tz/assets/images/commit_internals.png" alt="commit_internals" width="500" height="auto" /></p>

<h2 id="-subsequent-commit-with-changes">ğŸ”ƒ Subsequent Commit with Changes</h2>

<p>When you modify one of the files and commit again, Git handles the changes efficiently:</p>

<ul>
  <li><em>New Blob for the modified file:</em> A new blob is created for the modified file, containing only the changes.</li>
  <li><em>Reused Blobs for unchanged files:</em> Git reuses the blobs for the files that havenâ€™t been modified, saving space and processing time.</li>
  <li><em>New Tree:</em> A new tree object is created that points to the correct mix of old and new blobs. This ensures the updated file structure reflects the changes.</li>
  <li><em>New Commit Object:</em> A new commit object is created, pointing to the new tree. It also points to the previous commit as its parent, preserving the commit history.</li>
</ul>

<h2 id="ï¸-branching-and-the-role-of-head">ğŸ—’ï¸ Branching and the Role of HEAD</h2>
<p>The <strong>main branch (and HEAD)</strong> points to the latest commit, effectively continuing the chain of commits. This structure â€” consisting of snapshots (blobs), directories (trees), and commit objects â€” is what makes Git branching so fast and powerful. Each new commit doesnâ€™t duplicate data but rather builds upon the existing objects, making the entire process efficient and scalable.</p>

<hr />
<h1 id="-git-branching-and-merging">ğŸ”— Git Branching and Merging</h1>
<p>Git branching is a powerful feature that allows you to develop features, fix bugs, or experiment with new ideas in isolation â€” without affecting the main codebase.</p>

<p>A <strong>branch in Git</strong> is essentially a lightweight pointer to a specific commit. When you create a new branch, youâ€™re starting a separate line of development, allowing you to make changes independently of the default branch (often called main or master).</p>

<p>Each time you commit on a branch, the branch pointer (e.g., main or feature-xyz) automatically advances to point to the latest commit. This way, Git tracks the evolution of that branch as development continues.</p>

<p><strong>Merging in Git</strong> combines the changes from one branch (like feature) into another (like main) by creating a merge commit that links the histories of both branches.</p>

<p>The diagram below illustrates how Git handles branching and merging, starting from a common base commit and progressing through independent development on a feature branch:</p>

<p><img src="/Techn0tz/assets/images/Git_branching_eg.png" alt="Branching_eg" width="500" height="auto" /></p>

<p>The table below shows a typical workflow and commit relationships</p>

<table>
  <thead>
    <tr>
      <th><strong>Commit</strong></th>
      <th><strong>Branch</strong></th>
      <th><strong>Parent(s)</strong></th>
      <th><strong>Explanation</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>A</td>
      <td>main</td>
      <td>initial commit</td>
      <td>First commit in the repo</td>
    </tr>
    <tr>
      <td>B</td>
      <td>main</td>
      <td>A</td>
      <td>B is the next commit after A</td>
    </tr>
    <tr>
      <td>C</td>
      <td>main</td>
      <td>B</td>
      <td>C follows B; the point where feature branch is created</td>
    </tr>
    <tr>
      <td>D</td>
      <td>feature</td>
      <td>C</td>
      <td>First commit on <code class="language-plaintext highlighter-rouge">feature</code>, created from <code class="language-plaintext highlighter-rouge">main</code> at C</td>
    </tr>
    <tr>
      <td>E</td>
      <td>feature</td>
      <td>D</td>
      <td>Continues work in <code class="language-plaintext highlighter-rouge">feature</code> branch</td>
    </tr>
    <tr>
      <td>F</td>
      <td>main</td>
      <td>C, E</td>
      <td>Merge commit: merges <code class="language-plaintext highlighter-rouge">feature</code> back into <code class="language-plaintext highlighter-rouge">main</code></td>
    </tr>
  </tbody>
</table>

<hr />
<h1 id="-git-branching-and-merging-commands">ğŸ“œ Git Branching and Merging commands</h1>

<table>
  <thead>
    <tr>
      <th><strong>Command</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git branch</code></td>
      <td>Lists all local branches in the repository</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git branch &lt;branch-name&gt;</code></td>
      <td>Creates a new branch</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git checkout &lt;branch-name&gt;</code></td>
      <td>Switches to the specified branch</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git switch &lt;branch-name&gt;</code></td>
      <td>Alternative to checkout (modern &amp; safer)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git checkout -b &lt;branch-name&gt;</code></td>
      <td>Creates and switches to a new branch</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git switch -c &lt;branch-name&gt;</code></td>
      <td>Equivalent to the above (more readable syntax)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git branch -d &lt;branch-name&gt;</code></td>
      <td>Deletes a local branch (only if itâ€™s merged)</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git branch -D &lt;branch-name&gt;</code></td>
      <td>Force-deletes a local branch (even if unmerged)</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th><strong>Command</strong></th>
      <th><strong>Description</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git merge &lt;branch-name&gt;</code></td>
      <td>Merges the given branch into the current branch</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git merge --no-ff &lt;branch-name&gt;</code></td>
      <td>Creates a merge commit even if a fast-forward is possible</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">git log --graph --oneline</code></td>
      <td>Shows a visual history of commits with branches/merges</td>
    </tr>
  </tbody>
</table>

<hr />
<h1 id="branching-and-merging-in-action-a-snapshot-example">ğŸ’¡Branching and Merging in Action: A Snapshot Example</h1>
<p>Below is a snapshot demonstrating how branching and merging work using Git commands.</p>

<p><img src="/Techn0tz/assets/images/branching_eg2.png" alt="branching_eg2" />
<img src="/Techn0tz/assets/images/branching_eg1.png" alt="branching_eg1" /></p>

<h2 id="-result">âœ… Result</h2>
<p>You can use the <strong><code class="language-plaintext highlighter-rouge">start index.html</code></strong> command (on Windows) to open the developed HTML page in your default browser and check if the merged content displays correctly.</p>

<hr />
<h1 id="-conclusion">ğŸ“ƒ Conclusion</h1>
<p>Branching and merging are powerful features of Git that help you work on different tasks without affecting the main code. By creating branches, you can develop features safely, and by merging, you bring everything back together. With regular practice, these commands will become second nature and make your workflow smoother and more organized.</p>

<hr />
<h2 id="-technuggetz---did-you-know">ğŸ§  TechNuggetz - Did you know?</h2>
<blockquote>

  <p>ğŸ”§ A <strong>hotfix branch</strong> is a special-purpose Git branch used to quickly patch a bug in production without waiting for ongoing development to finish.</p>

  <p>ğŸ” Clean up merged branches using <strong><code class="language-plaintext highlighter-rouge">git branch -d branch_name (or -D to force)</code></strong>.</p>

  <p>â›“ï¸â€ğŸ’¥ Use <strong>merge</strong> for team work, <strong>rebase</strong> for cleaner individual history.</p>

  <p>ğŸ’­ <strong><code class="language-plaintext highlighter-rouge">git log --oneline --decorate</code></strong> can also be used to view branches and merges</p>

  <p>ğŸ§­ <strong><code class="language-plaintext highlighter-rouge">git switch</code></strong> is a newer and clearer alternative to <strong><code class="language-plaintext highlighter-rouge">git checkout</code></strong> for switching branches.</p>
</blockquote>

<hr />
<h2 id="-next-on-techn0tz">ğŸ”œ Next on Techn0tz</h2>
<p><em>Developing a GitHub page using Jekyll on windows</em></p>]]></content><author><name></name></author><category term="Git" /><summary type="html"><![CDATA[ğŸ“How Git stores Data? Before diving into branching, itâ€™s important to understand how Git stores your project. Unlike some older version control systems, Git doesnâ€™t store data as a series of changesets or differences. Instead, it stores your project as a series of snapshots.]]></summary></entry><entry><title type="html">Git Series: Part 2 - Remote repository - GitHub</title><link href="http://localhost:4000/Techn0tz/git/2025/04/25/Git-Series-Part-2.html" rel="alternate" type="text/html" title="Git Series: Part 2 - Remote repository - GitHub" /><published>2025-04-25T00:00:00+05:30</published><updated>2025-04-25T00:00:00+05:30</updated><id>http://localhost:4000/Techn0tz/git/2025/04/25/Git-Series-Part-2</id><content type="html" xml:base="http://localhost:4000/Techn0tz/git/2025/04/25/Git-Series-Part-2.html"><![CDATA[<h2 id="-missed-part-1-">ğŸ”— Missed Part-1 ?</h2>
<p>ğŸ‘‰ Checkout <strong><a href="/Techn0tz/git/2025/04/25/Git-Series-Part-1">Git Series: Part1 - Local Version Control</a></strong> to get familiar with the basics of Git and how local version control works</p>

<hr />
<h1 id="ï¸-remote-repository">ğŸ—ºï¸ Remote Repository</h1>
<h2 id="-connecting-your-local-repository-to-github">ğŸ”„ Connecting Your Local Repository to GitHub</h2>
<p>Once youâ€™ve committed your changes locally, the next step is to upload (push) your code to GitHub so itâ€™s safely stored online and ready to share or collaborate</p>

<h2 id="-creating-a-new-repository-on-github">ğŸ†• Creating a new repository on GitHub</h2>
<ul>
  <li>Go to <strong>https://github.com</strong></li>
  <li>Click on â• New repository</li>
  <li>Fill in:
    <ul>
      <li>Repository name (e.g., my-demo-project)</li>
      <li>Choose Public or Private</li>
      <li>DO NOT check â€œInitialize this repository with a READMEâ€ (since you already have local files)</li>
    </ul>
  </li>
  <li>Click Create repository</li>
</ul>

<h2 id="-link-repo-to-github-and-pushing-to-remote-repository">ğŸ’» Link Repo to GitHub and pushing to remote repository</h2>

<ul>
  <li>Before pushing to GitHub, use <strong><code class="language-plaintext highlighter-rouge">git branch -M main</code></strong> command - to rename Gitâ€™s default branch <strong>master to main</strong>
    <ul>
      <li>Git defaults to master, but GitHub uses main, so renaming it helps avoid conflicts when pushing to GitHub.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">git remote add origin https://github.com/your-username/my-demo-project.git</code></strong> command- Git adds a new connection to the remote repo
    <ul>
      <li><em>Replace URL with your actual repository URL</em></li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">git push -u origin main</code></strong> command - the changes that are committed locally are sent to the <em>main branch</em> of your GiHubâ€™s repository
    <ul>
      <li>-u or â€“set upstream is used only for initial push</li>
      <li>Next time when you want to push to same branch just use <em>git push</em></li>
    </ul>
  </li>
</ul>

<p>ğŸ¥‡<strong>Now your code is live on GitHub! You can visit your repository URL to confirm</strong></p>

<hr />
<h1 id="ï¸-remote-repository-workflow">ğŸ–‹ï¸ Remote repository workflow</h1>

<p>After setting up your project with LVC,the remote repository workflow connects it to a remote server like GitHub for collaboration and version control</p>

<p><img src="/Techn0tz/assets/images/Remote_workflow.png" alt="Remote Workflow" width="500" height="auto" /></p>

<hr />
<h1 id="example-snapshot-pushing-git-project-to-github">ğŸ’¡Example Snapshot: Pushing Git project to GitHub</h1>

<p>The first snapshot is from <strong>Part-1</strong>, given just for reference</p>

<p><img src="/Techn0tz/assets/images/LVC_snapshot.png" alt="LVC_example" /></p>

<p>continues below, complementing the remote repository snapshot for a complete view of the Git workflow.</p>

<p><img src="/Techn0tz/assets/images/Push_file_to_GitHub.png" alt="GitHub_example" /></p>

<p>The above snapshot visualizes the workflow involved in linking your local repository with a remote platform like GitHub, enabling version control beyond your machine.</p>

<h2 id="-result">âœ… Result</h2>
<p>ğŸ†<strong><em>Go to your GitHub repo and youâ€™ll see hello.txt uploaded â€” success!</em></strong></p>

<hr />
<h1 id="-full-git-journey-summary">ğŸ“‘ Full Git Journey Summary</h1>

<table>
  <thead>
    <tr>
      <th><strong>Step</strong></th>
      <th><strong>Action</strong></th>
      <th><strong>Command</strong></th>
      <th><strong>Stage</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>Initialize Git</td>
      <td>git init</td>
      <td>Working Directory</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Create/edit files</td>
      <td>echo, touch, nano, etc.</td>
      <td>Working Directory</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Stage changes</td>
      <td>git add</td>
      <td>Staging Area</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Commit changes</td>
      <td>git commit -m â€œâ€¦â€</td>
      <td>Local Repository</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Create GitHub repo</td>
      <td>(via web browser)</td>
      <td>â€”</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Link local repo to GitHub</td>
      <td>git remote add origin URL</td>
      <td>Remote Setup</td>
    </tr>
    <tr>
      <td>7</td>
      <td>Push to GitHub</td>
      <td>git push -u origin main</td>
      <td>Remote Repository</td>
    </tr>
  </tbody>
</table>

<hr />
<h1 id="-git-quick-fixes--what-it-says-vs-what-it-means">ğŸ” Git Quick Fixes- What it says vs What it means</h1>

<table>
  <thead>
    <tr>
      <th><strong>Git Says</strong></th>
      <th><strong>What It Means</strong></th>
      <th><strong>What You Can Do</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>nothing to commit, working tree clean</td>
      <td>Youâ€™ve staged and committed everything already</td>
      <td>Youâ€™re up to date! Keep working</td>
    </tr>
    <tr>
      <td>fatal: not a git repository</td>
      <td>Youâ€™re in a folder that isnâ€™t initialized</td>
      <td>Run <em><code class="language-plaintext highlighter-rouge">git init</code></em> or go to the right folder</td>
    </tr>
    <tr>
      <td>no changes added to commit</td>
      <td>You changed files but didnâ€™t stage them yet</td>
      <td>Run <em><code class="language-plaintext highlighter-rouge">git add filename</code></em></td>
    </tr>
    <tr>
      <td>Your branch is ahead of â€˜origin/mainâ€™</td>
      <td>You have local commits not pushed to GitHub</td>
      <td>Run <em><code class="language-plaintext highlighter-rouge">git push</code></em></td>
    </tr>
    <tr>
      <td>error: failed to push some refs</td>
      <td>Usually a mismatch with GitHub (e.g., branch name)</td>
      <td>Run <em><code class="language-plaintext highlighter-rouge">git pull origin main --rebase</code></em>, then <em><code class="language-plaintext highlighter-rouge">git push</code></em></td>
    </tr>
    <tr>
      <td>merge conflict in filename</td>
      <td>Git found conflicting changes between branches</td>
      <td>Open the file, resolve conflicts, then <em><code class="language-plaintext highlighter-rouge">git add + git commit</code></em></td>
    </tr>
    <tr>
      <td>rejected - non-fast-forward</td>
      <td>Remote repo changed and your local copy is outdated</td>
      <td>Run <em><code class="language-plaintext highlighter-rouge">git pull</code></em> first, resolve conflicts, then push again</td>
    </tr>
    <tr>
      <td>fatal: remote origin already exists</td>
      <td>Youâ€™ve already added a remote</td>
      <td>Run <em><code class="language-plaintext highlighter-rouge">git remote set-url origin &lt;url&gt;</code></em> to change it</td>
    </tr>
  </tbody>
</table>

<hr />
<h1 id="-conclusion">ğŸ“ƒ Conclusion</h1>

<p>Understanding the Git workflow â€” from your working directory to the remote repository â€” is the foundation of effective version control.In this post we saw  how files move through Local version control to online using real commands, visuals, and hands-on examples.
Whether youâ€™re working solo or collaborating with others, mastering these Git basics will help you track changes, avoid mistakes, and push your projects confidently to GitHub</p>

<hr />
<h2 id="-technuggetz---did-you-know">ğŸ’¡ TechNuggetz - Did you Know?</h2>

<blockquote>
  <p>ğŸ“‡ GitHub isnâ€™t a centralized VCS â€” itâ€™s a remote platform where teams collaborate using Git. The version control stays distributed, even when using GitHub.</p>

  <p>â­ The name GitHub comes from <strong>Git</strong> (the version control tool) + <strong>Hub</strong> (a central place where developers collaborate). Itâ€™s literally a hub for Git repositories!</p>

  <p>ğŸ’­ Always run <strong><code class="language-plaintext highlighter-rouge">git pull</code></strong> before <strong><code class="language-plaintext highlighter-rouge">git push</code></strong> to avoid merge surprises when working in teams!</p>
</blockquote>

<hr />
<h2 id="--next-on-techn0tz">ğŸ”œ  Next on Techn0tz..</h2>

<p><em>Git - Branching and Merging</em></p>]]></content><author><name></name></author><category term="Git" /><summary type="html"><![CDATA[ğŸ”— Missed Part-1 ? ğŸ‘‰ Checkout Git Series: Part1 - Local Version Control to get familiar with the basics of Git and how local version control works]]></summary></entry><entry><title type="html">Git Series: Part 1 - Local Version Control</title><link href="http://localhost:4000/Techn0tz/git/2025/04/25/Git-Series-Part-1.html" rel="alternate" type="text/html" title="Git Series: Part 1 - Local Version Control" /><published>2025-04-25T00:00:00+05:30</published><updated>2025-04-25T00:00:00+05:30</updated><id>http://localhost:4000/Techn0tz/git/2025/04/25/Git-Series-Part-1</id><content type="html" xml:base="http://localhost:4000/Techn0tz/git/2025/04/25/Git-Series-Part-1.html"><![CDATA[<h1 id="-from-vcs-to-git">ğŸš€ From VCS to Git</h1>

<p>In the last post, we explored Version Control System and their types â€” CVCS and DVCS. Now, letâ€™s zoom into the most popular DVCS tool in the world: <strong>Git</strong> â€” and see how it powers modern development.</p>

<hr />
<h1 id="-what-is-git">ğŸ“œ What is Git?</h1>

<p>Git is open source Distributed Version Control Sytem which allows developers</p>
<ul>
  <li>Track changes in code over time</li>
  <li>Collaborate seamlessly with teammates</li>
  <li>Create branches for experimental study</li>
  <li>Roll back to previous versions when things goes wrong</li>
</ul>

<blockquote>
  <p>âŒ›Think of Git as your <strong>projects time machine</strong> - but smarter, faster and made for team work</p>
</blockquote>

<hr />
<h1 id="-core-components-git-and-lvc-worflow">ğŸ¯ Core Components Git and LVC worflow</h1>

<p>The Git workflow is a step-by-step process that defines how changes in a project move from your local machine to a shared, remote repository like GitHub. Mastering this flow helps you collaborate smoothly and  manage versions efficiently.</p>

<p><strong>This post explains about Git basics and how the files are committed locally</strong></p>

<p>The core components of LVC worflow are: <strong>Working Directory, Staging Area, Local Repository</strong>. Understanding how files move through these stages are essential.</p>

<p><img src="/Techn0tz/assets/images/LVC_workflow.png" alt="LVC Workflow" width="500" height="auto" /></p>

<p>The diagram above outlines the LVC process. Now, letâ€™s explore each stage and see how your local project files eventually become committed, shared history.</p>

<h2 id="-working-directory">ğŸ“‚ Working Directory</h2>

<p>This is the local folder on your computer where you edit and work on your project files</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">git init</code></strong> command - Intializes a Git repository
    <ul>
      <li>The Git starts tracking the specified folder as a Git project- in other words, your plain folder(working directory) is converted into .Git project</li>
      <li>Creates a hidden <strong>.git.</strong> folder in the working directory</li>
      <li>This .git/  folder contains everything that Git needs to track your project (eg. commit, branch, logs etc)</li>
      <li>Your <strong>working directory stays the same</strong>, but now Git is watching for changes</li>
    </ul>
  </li>
</ul>

<h2 id="ï¸-staging-area">ğŸ—ƒï¸ Staging Area</h2>

<p>The staging area (index) is like a holding zone- where Git gathers all the changes that you want to commit</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">git add</code></strong> command - moves the changes from working directory to the staging area
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">git add filename</code></strong> - Adds a specific file to the staging area</li>
      <li><strong><code class="language-plaintext highlighter-rouge">git add .</code></strong> - Adds all the modified files in the folder</li>
    </ul>
  </li>
</ul>

<h2 id="-local-repository">ğŸ“ Local Repository</h2>

<p>The local repository is the <strong>.git directory</strong>- which is the Gitâ€™s repository storage</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git commit</code> command - the changes from the staging area are permanently stored in the repository
    <ul>
      <li>The repository is located inside the hidden <strong>.git/</strong> folder- the one created by <strong><code class="language-plaintext highlighter-rouge">git init</code></strong></li>
      <li>The .git directory contains all the commits, project history, branches, logs etc</li>
    </ul>
  </li>
</ul>

<h1 id="example-snapshot-from-init-to-commit-in-lvc">ğŸ’¡Example Snapshot: From init to commit in LVC</h1>

<p>The snapshot below provides a practical example of how to create a new directory, initialize a Git repository, and set up local version control. It will walk you through the essential steps, including adding files to the staging area, committing changes, and managing version history on your local machine. By following along, youâ€™ll gain hands-on experience in using Git for efficient source code management.</p>

<p><img src="/Techn0tz/assets/images/LVC_snapshot.png" alt="LVC_example" /></p>

<hr />
<h2 id="-technuggetz---did-you-know">ğŸ§  TechNuggetz - Did you Know?</h2>

<blockquote>
  <p>âŒ› <strong>Git</strong> was built by <strong>Linus Torvalds - Founder of Linus</strong> in just 2 weeks in 2005 - Iconic!</p>

  <p>â˜‘ï¸ <strong>Git</strong> knows everything locally, it dosenâ€™t need internet to track changes - from version history, staging and committing - everithing happens in your local machine.</p>

  <p>âŒ Made a mistake? <strong><code class="language-plaintext highlighter-rouge">git checkout -- filename</code></strong> - restores a file to its last committed state</p>

  <p>ğŸ—‚ï¸ Track only what matters! Use a <strong><code class="language-plaintext highlighter-rouge">.gitignore</code></strong> file to prevent sensitive data (like passwords, logs, or config files) from slipping into your commits. A cleaner repo is a safer repo!</p>

  <p>ğŸª„ Autosave magic! Use <strong><code class="language-plaintext highlighter-rouge">git stash</code></strong> to save your work-in-progress without a commit. Come back later with <strong><code class="language-plaintext highlighter-rouge">git stash pop</code></strong> and pick up right where you left off!</p>
</blockquote>

<p>Continue.. <strong>ğŸ‘‰ To push your Git project to Remote repository like GitHub <a href="/Techn0tz/git/2025/04/25/Git-Series-Part-2">Part-2:Remote-repository</a></strong></p>

<p><strong><em>Happy Learning!</em></strong></p>]]></content><author><name></name></author><category term="Git" /><summary type="html"><![CDATA[ğŸš€ From VCS to Git]]></summary></entry><entry><title type="html">Version Control: The Backbone of Modern Development</title><link href="http://localhost:4000/Techn0tz/vcs/and/dvcs/2025/04/18/vcs-cvcs-dvcs.html" rel="alternate" type="text/html" title="Version Control: The Backbone of Modern Development" /><published>2025-04-18T00:00:00+05:30</published><updated>2025-04-18T00:00:00+05:30</updated><id>http://localhost:4000/Techn0tz/vcs/and/dvcs/2025/04/18/vcs-cvcs-dvcs</id><content type="html" xml:base="http://localhost:4000/Techn0tz/vcs/and/dvcs/2025/04/18/vcs-cvcs-dvcs.html"><![CDATA[<p>In the fast-paced world of software development, change is constant. Developers write, rewrite, test, and refine code every day. Without a system to manage those changes, projects would quickly become chaotic. Thatâ€™s where <strong>Version Control Systems (VCS)</strong> come in.</p>

<p>This post explains the basics of VCS, differences between <strong>Centralized</strong> and <strong>Distributed</strong> systems</p>

<hr />

<h1 id="-what-is-version-control-system">ğŸ§¾ What is Version Control System?</h1>

<p>A <strong>Version Control System (VCS)</strong> is a tool that helps developers <strong>track changes in code</strong>, <strong>collaborate effectively</strong>, <strong>experiment safely using branches</strong>, and <strong>revert to previous versions</strong> if something goes wrong.</p>

<h2 id="ï¸-imagine-youre-part-of-a-high-profile-investigation">ğŸ•µï¸ Imagine youâ€™re part of a high-profile investigationâ€¦</h2>

<p>Every document related to the investigation â€” updates, evidence, and changes â€” is crucial and must be recorded in a <strong>master case file</strong>. This file evolves over time and needs to be updated consistently throughout the process.</p>

<p>Thatâ€™s exactly what a <strong>Version Control System (VCS)</strong> does in software development.</p>

<p>It records detailed notes, timestamps, author information, and every change made â€” allowing you to go back to any previous version when needed. It also enables <strong>multiple detectives (developers)</strong> to collaborate on the same case without overwriting each otherâ€™s work.</p>

<hr />

<h1 id="ï¸-centralized-version-control-cvcs">ğŸ—‚ï¸ Centralized Version Control (CVCS)</h1>

<p>In a <strong>Centralized Version Control System</strong>, there is one single <strong>central repository</strong> where all versions of code are stored. Developers connect to this central server to get the latest version of the code or to make updates.</p>

<p>âœ… Advantages:</p>
<ul>
  <li>Simple and easy to set up</li>
  <li>Everyone works on the same central version</li>
</ul>

<p>âš ï¸ Disadvantages:</p>
<ul>
  <li>Requires constant internet connection</li>
  <li>If the central server fails, you lose access to everything</li>
</ul>

<p><strong>Examples</strong>: SVN (Subversion), CVS</p>

<hr />

<h1 id="-decentralized-version-control-dvcs">ğŸ”„ Decentralized Version Control (DVCS)</h1>

<p>In a <strong>Distributed Version Control System</strong>, every developer has a <strong>complete copy of the codebase</strong>, including its full history. This allows for better collaboration, offline access, and safer experimentation.</p>

<p>âœ… Advantages:</p>
<ul>
  <li>Work offline with full project history</li>
  <li>Fast operations (commits,merges)</li>
  <li>No single point of failure</li>
</ul>

<p>âš ï¸ Disadvantages:</p>
<ul>
  <li>More complex branching/merging (initially)</li>
</ul>

<p><strong>Examples</strong>: Git, Mercurial</p>

<hr />

<h1 id="-summary">ğŸ“„ Summary</h1>

<table>
  <thead>
    <tr>
      <th><strong>Feature</strong></th>
      <th><strong>CVCS</strong></th>
      <th><strong>DVCS</strong></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Central Repository</td>
      <td>Yes</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Full History Locally</td>
      <td>No</td>
      <td>Yes</td>
    </tr>
    <tr>
      <td>Offline Work</td>
      <td>Limited</td>
      <td>Fully Supported</td>
    </tr>
    <tr>
      <td>Collaboration Model</td>
      <td>Linear, centralized</td>
      <td>Distributed, flexible</td>
    </tr>
    <tr>
      <td>Examples</td>
      <td>SVN, CVS</td>
      <td>Git, Mercurial</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <h2 id="-technuggetz----did-you-know">ğŸ“¦ <strong>TechNuggetz</strong> - ğŸ“† <strong>Did you know?</strong></h2>

  <p>ğŸ§  <strong><em>Version Control</em></strong> dates back to the 1970s â€” with <strong>RCS</strong> and <strong>SCCS</strong>!</p>

  <p>â˜ï¸ In the <strong><em>Centralized Version Control</em></strong>, the server is the boss - if it goes down, no server, no service! <em>Time for a coffee!</em>â˜•</p>

  <p>ğŸŒ <strong>Distributed VCS</strong> like Git gives each developer a full copy of the repository â€” work offline, experiment freely, and break stuff without fear!</p>
</blockquote>

<hr />

<blockquote>
  <h2 id="-next-on-techn0tz">ğŸ”œ <strong>Next on Techn0tz</strong></h2>

  <p>ğŸ›¸ <strong>Git</strong> - commands and workflows</p>
</blockquote>]]></content><author><name></name></author><category term="VCS" /><category term="and" /><category term="DVCS" /><summary type="html"><![CDATA[In the fast-paced world of software development, change is constant. Developers write, rewrite, test, and refine code every day. Without a system to manage those changes, projects would quickly become chaotic. Thatâ€™s where Version Control Systems (VCS) come in.]]></summary></entry></feed>